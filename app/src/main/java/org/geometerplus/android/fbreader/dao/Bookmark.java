package org.geometerplus.android.fbreader.dao;


import android.graphics.Color;

import org.geometerplus.fbreader.util.TextSnippet;
import org.geometerplus.zlibrary.text.view.ZLTextElement;
import org.geometerplus.zlibrary.text.view.ZLTextFixedPosition;
import org.geometerplus.zlibrary.text.view.ZLTextPosition;
import org.geometerplus.zlibrary.text.view.ZLTextView;
import org.geometerplus.zlibrary.text.view.ZLTextWord;
import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import java.util.Date;
import java.util.UUID;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END

/**
 * Entity mapped to table "reader_highlight".
 */
public class Bookmark {

  /**
   * 唯一标识
   */
  public Long id;
  /**
   * 书籍唯一Code
   */
  public Long bookCode;
  /**
   * 书签类型, 1. 标注, 2. 书签
   */
  public int type = 1;
  public String uid;
  public boolean visible = true;
  public int foregroundColor = -1;
  public int backgroundColor = Color.YELLOW;
  public String title;
  public String text;
  public Date creationTime;
  public Date modificationTime;
  public ZLTextFixedPosition startPosition;
  public ZLTextFixedPosition endPosition;

  private int mLength;

  /** Used to resolve relations */
  private transient BooksDaoSession daoSession;

  /** Used for active entity operations. */
  private transient BookmarksDao myDao;

  // KEEP FIELDS - put your custom fields here
  // KEEP FIELDS END

  public Bookmark() {
  }

  public Bookmark(Long id) {
    this.id = id;
  }

  public Bookmark(Long pId, Long pBookCode, int pType, String pUid, boolean pVisible,
      int fgColor, int bgColor, String pTitle, String pText, Date pCreationTime,
      Date pModificationTime, int pParagraph, int pWord, int pCharacter,
      Integer pEndParagraph, Integer pEndWord, Integer pEndCharacter) {
    this.id = pId;
    this.bookCode = pBookCode;
    this.type = pType;
    this.uid = verifiedUUID(pUid);
    this.visible = pVisible;
    this.foregroundColor = fgColor;
    this.backgroundColor = bgColor;
    this.title = pTitle;
    this.text = pText;
    this.creationTime = pCreationTime;
    this.modificationTime = pModificationTime;
    startPosition = new ZLTextFixedPosition(pParagraph, pWord, pCharacter);

    if (null != pEndCharacter) {
      endPosition = new ZLTextFixedPosition(pEndParagraph, pEndWord, pEndCharacter);
    } else {
      mLength = pEndParagraph;
    }
  }

  public Bookmark(Long pBookCode, TextSnippet snippet, boolean pVisible) {
    bookCode = pBookCode;
    uid = newUUID();
    visible = pVisible;
    text = snippet.getText();
    creationTime = new Date();
    startPosition = new ZLTextFixedPosition(snippet.getStart());
    endPosition = new ZLTextFixedPosition(snippet.getEnd());
  }

  /** called by internal mechanisms, do not call yourself. */
  public void __setDaoSession(BooksDaoSession daoSession) {
    this.daoSession = daoSession;
    myDao = daoSession != null ? daoSession.getBookmarksDao() : null;
  }

  /**
   * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity
   * context.
   */
  public void delete() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.delete(this);
  }

  /**
   * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity
   * context.
   */
  public void update() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.update(this);
  }

  /**
   * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity
   * context.
   */
  public void refresh() {
    if (myDao == null) {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.refresh(this);
  }

  // KEEP METHODS - put your custom methods here
  private static String newUUID() {
    return UUID.randomUUID().toString();
  }

  private static String verifiedUUID(String uid) {
    if (uid == null || uid.length() == 36) {
      return uid;
    }
    throw new RuntimeException("INVALID UUID: " + uid);
  }

  public void findEnd(ZLTextView view) {
    if (endPosition != null) {
      return;
    }
    ZLTextWordCursor cursor = view.getStartCursor();
    if (cursor.isNull()) {
      cursor = view.getEndCursor();
    }
    if (cursor.isNull()) {
      return;
    }
    cursor = new ZLTextWordCursor(cursor);
    cursor.moveTo(startPosition);

    ZLTextWord word = null;
    mainLoop:
    for (int count = mLength; count > 0; cursor.nextWord()) {
      while (cursor.isEndOfParagraph()) {
        if (!cursor.nextParagraph()) {
          break mainLoop;
        }
      }
      final ZLTextElement element = cursor.getElement();
      if (element instanceof ZLTextWord) {
        if (word != null) {
          --count;
        }
        word = (ZLTextWord)element;
        count -= word.Length;
      }
    }
    if (word != null) {
      endPosition = new ZLTextFixedPosition(cursor.getParagraphIndex(), cursor.getElementIndex(), word.Length);
    }
  }

  public void setEnd(int paragraphIndex, int elementIndex, int charIndex) {
    endPosition = new ZLTextFixedPosition(paragraphIndex, elementIndex, charIndex);
  }

  // KEEP METHODS END
}
